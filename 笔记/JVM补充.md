# JVM补充

## 编译器

**寻常所说的编译器是指把汇编语言转变成机器语言，也称目标代码，即CPU指令集。**汇编语言是一种比机器语言对人友好的语言，但不同机器硬件构造不一样，驱动机器的软件也不一样，因此汇编语言需要针对不同的机器编写不同的代码，显得有点麻烦。为解决这个问题，聪明的工程师想到一种方法，即采用虚拟机的形式屏蔽底层硬件和软件平台的不同，也就是说，高级语言的编写不受底层硬件的影响，达到“一次编译，到处运行”的效果。
很明显，“一次编译，到处运行”的功能寄托于虚拟机；**java语言是基于java虚拟机(JVM)而实现的一种高级语言，它需要通过java编译器编译成JVM识别的语言，最后由JVM实现到目标语言的转换**

![编译器编译过程](C:\Users\LangFo.zheng\Desktop\编译器编译过程.png)

从java语言到字节码的转变要经过四个过程：

​	①java语言到Token流的过程，称为词法分析；

​	②Token流到抽象语法树的过程，称为语法分析；

​	③解析复杂的树节点，如语法糖的解析等，称为语义分析；

​	④抽象语法树到字节码的过程，称为代码生成。

##### 何为词法分析？

词法分析从字面来理解就是解析java语言中的单词；单纯的从字面来看，java文件由java关键字、标识符(包名、类名、属性名和方法名)以及符号(各类运算符、各类括号)等三部分组成。词法分析的主要目的就是把这些单词和符号转变成Token流。

##### 词法分析的过程？

词法分析在源代码中是和语法分析在一起的，在这里为了更好的理解词法分析的过程，我是从代码的执行角度来分析的。有如下代码：

```java
package com.compile;
public class CifaAnalysis {
	int i = 0;
	public static void main(String[] args) {
		System.out.println("Hello World!");
	}
}
1234567
```

大体过程如下：
①通过com.sun.tools.javac.main.Main类的compile()方法读取.java文件；
②通过com.sun.tools.javac.main.JavaCompiler.readSource(JavaFileObject)方法把文件内容转变成字符流(charSequence)；
③通过com.sun.tools.javac.parser.Scanner.nextToken()方法从字符流中获取一个token；
**长串字符流如何形成一个个token？token长啥样？**
针对第一个问题，nextToken()方法说的很清楚，由于方法过长，这里就不黏贴出来，简单的说就是一个一个字符读取字符流，比如”package com.compile”，当读取p-a-c-k-a-g-e-空格，识别到空格时则会把空格前的字符流组成一个token字符串.(Token是一个枚举类，列举了所有的关键字、各类运算符和符号等)。或许你在这里还有一个疑问，如果一个双目运算符两边没有空格如int i=0该如何形成四个token而不是两个？在nextToken方法里面已经对这种特殊操作符(!%&*?±:<=>|~@)进行了特殊的处理。

说说token是怎么处理的了。
原来Token类里面的name到value的映射是由com.sun.tools.javac.parser.Keywords.Keywords(Context)方法完成的，每一个token都以Name类的对象存储在Token类型的数组内；

maxKey表示Token枚举类的数量；通过第二个for循环把映射关系（name-value）初始化好，name没有映射的value则value为IDENTIFIER；因此当nextToken()方法形成一个token时会定义为name对象，然后根据这个name对象去key数组中查找对应的value，没有找到对应关系的name，其value为IDENTIFIER，所以com/compile等标识符都会被定义为IDENTIFIER；

![token流](C:\Users\LangFo.zheng\Desktop\token流.jpg)

编译器知道Token.PACKAGE后面跟的是包名，Token.IMPORT后面跟的是导入的类名；Token.CLASS后面是类名等等这些都是事先约定好的，可以认为是java语言的规范。

##### 总结

到此，词法分析的整个过程结束了。可以整理下流程：
->读取.java源文件，并转换为字符流；
->读取字符流，根据规则形成name对象，并映射成Token；
->一个个Token形成Token流；

语义分析做了哪几件事？这几件事分别通过什么方法完成的？最后的结果是什么？

##### 1. java类中的符号输入到符号表；（添加默认的构造器）

过程：即把抽象语法树中符号输入到符号表中，这里的符号包括import节点上的符号，类名，类成员以及方法等。符号表主要有符号地址和符号信息，用于语义检查和地址分配。
方法：com.sun.tools.javac.main.JavaCompiler.enterTrees(List)
结果：抽象语法树

##### 2. 处理注解

过程：处理注解（Annotation）的其实是一组API，用来在编译期间处理注解；我认为，处理主要是指对注解的实际意义进行解析，比如@RequestMapping，它是用来完成映射，那么处理后的结果就要形成映射关系。
方法：com.sun.tools.javac.main.JavaCompiler.processAnnotations(List, List)
结果：注解语法树

## class文件内容

 Class文件是一组以8位字节为基础单位的二进制流，各个数据项目严格按照顺序紧凑地排列在Class文件中，中间没有添加任何分隔符，这使得整个Class文件中存储的内容几乎全部都是程序运行的必要数据。

整个Class文件本质上就是一张表，它由如下所示的数据项构成。

  从表中可以看出，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会使用一个前置的容量计数器加若干个连续的该数据项的形式，称这一系列连续的摸一个类型的数据为某一类型的集合，比如，fields_count个field_info表数据构成了字段表集合。这里需要说明的是：Class文件中的数据项，都是严格按照上表中的顺序和数量被严格限定的，每个字节代表的含义，长度，先后顺序等都不允许改变。

![class文件内容](C:\Users\LangFo.zheng\Desktop\class文件内容.png)

Class文件中各个数据项的具体含义：

![image-20201130132656333](C:\Users\LangFo.zheng\AppData\Roaming\Typora\typora-user-images\image-20201130132656333.png)

从表中可以看出，无论是无符号数还是表，当需要描述同一类型但数量不定的多个数据时，经常会在其前面使用一个前置的容量计数器来记录其数量，而便跟着若干个连续的数据项，称这一系列连续的某一类型的数据为某一类型的集合，如：fields_count个field_info表数据便组成了方法表集合。这里需要注意的是：Class文件中各数据项是按照上表的顺序和数量被严格限定的，每个字节代表的含义、长度、先后顺序都不允许改变。

### 一、魔数

每个class文件的头4个字节称为魔数，它唯一的作用是确定这个文件是否为一个能被虚拟机接受的Class文件。很多文件存储标准中都使用魔数来进行身份识别，譬如图片格式gif、jpeg等。使用魔数而不是拓展名来进行识别主要是基于安全方面的考虑，**因为文件拓展格式可以随意改动。**

Class文件的魔数为：**0xCAFEBABE**

### 二、版本号

第五六个字节是次版本号（Minor Version），第7和第8个字节是主版本号（Major Version）。

高版本的JDK可以向下兼容以前版本的Class文件，但是无法运行以后版本的Class文件，即使文件格式并未发生变化，虚拟机也必须拒绝执行超过其版本号的Class文件。

所以该文件的JDK版本  （3*15+4=52）= jdk1.8

### 三、常量池

常量池可以理解为Class文件之中的资源仓库，是Class文件结构中与其他项目关联最多的数据类型，也是占用Class文件空间最大的数据项目之一，同时也是在Class文件中第一个出现的表类型数据项目。

由于常量池中常量的数目是不固定的，所以在常量池入口需要放置一个2字节长的无符号数constatn_pool_count来代表常量池容量计数值。这个容量计数**从1而不是0开始。**

**constant_pool_count**：占2字节，0x0016，转化为十进制为22，即说明常量池中有21个常量（只有常量池的计数是从1开始的，其它集合类型均从0开始），索引值为1~22。**第0项常量**具有特殊意义，如果某些指向常量池索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”的含义，这种情况可以将索引值置为0来表示

常量池中主要存放两大类常量：字面量和符号引用。字面量如文本字符串、声明为final的常量值等。

符号引用包括三类常量：类和接口的全限定名、字段的名称和描述符、方法的名称和描述符。

虚拟机在加载Class文件时才会进行动态连接，也就是说，Class文件中不会保存各个方法和字段的最终内存布局信息，因此，这些字段和方法的符号引用不经过转换是无法直接被虚拟机使用的。当虚拟机运行时，需要从常量池中获得对应的符号引用，再在类加载过程中的解析阶段将其替换为直接引用，并翻译到具体的内存地址中。

这里说明下符号引用和直接引用的区别与关联：

- 符号引用：符号引用以一组符号来描述所引用的目标，符号可以是任何形式的字面量，只要使用时能无歧义地定位到目标即可。符号引用与虚拟机实现的内存布局无关，引用的目标并不一定已经加载到了内存中。
- 直接引用：直接引用可以是直接指向目标的指针、相对偏移量或是一个能间接定位到目标的句柄。直接引用是与虚拟机实现的内存布局相关的，同一个符号引用在不同虚拟机实例上翻译出来的直接引用一般不会相同。如果有了直接引用，那说明引用的目标必定已经存在于内存之中了。



常量池中的每一项常量都是一个表，在JDK1.7之前共有11种结构各不相同的表数据结构。这些表数据结构在表开始的第一位是一个u1类型的标志位，代表当前这个常量属于那种常量类型。如下表所示：

| 类型                             | 简介                     | 项目                                                    | 类型                     | 描述   |
| -------------------------------- | ------------------------ | ------------------------------------------------------- | ------------------------ | ------ |
| CONSTANT_Utf8_info               | utf-8缩略编码字符串      | tag                                                     | u1                       | 值为1  |
| length                           | u2                       | utf-8缩略编码字符串占用字节数                           |                          |        |
| bytes                            | u1                       | 长度为length的utf-8缩略编码字符串                       |                          |        |
| CONSTANT_Integer_info            | 整形字面量               | tag                                                     | u1                       | 值为3  |
| bytes                            | u4                       | 按照高位在前储存的int值                                 |                          |        |
| CONSTANT_Float_info              | 浮点型字面量             | tag                                                     | u1                       | 值为4  |
| bytes                            | u4                       | 按照高位在前储存的float值                               |                          |        |
| CONSTANT_Long_info               | 长整型字面量             | tag                                                     | u1                       | 值为5  |
| bytes                            | u8                       | 按照高位在前储存的long值                                |                          |        |
| CONSTANT_Double_info             | 双精度浮点型字面量       | tag                                                     | u1                       | 值为6  |
| bytes                            | u8                       | 按照高位在前储存的double值                              |                          |        |
| CONSTANT_Class_info              | 类或接口的符号引用       | tag                                                     | u1                       | 值为7  |
|                                  | index                    | u2                                                      | 指向全限定名常量项的索引 |        |
| CONSTANT_String_info             | 字符串类型字面量         | tag                                                     | u1                       | 值为8  |
| index                            | u2                       | 指向字符串字面量的索引                                  |                          |        |
| CONSTANT_Fieldref_info           | 字段的符号引用           | tag                                                     | u1                       | 值为9  |
| index                            | u2                       | 指向声明字段的类或接口描述符CONSTANT_Class_info的索引项 |                          |        |
| index                            | u2                       | 指向字段描述符CONSTANT_NameAndType_info的索引项         |                          |        |
| CONSTANT_Methodref_info          | 类中方法的符号引用       | tag                                                     | u1                       | 值为10 |
| index                            | u2                       | 指向声明方法的类描述符CONSTANT_Class_info的索引项       |                          |        |
| index                            | u2                       | 指向名称及类型描述符CONSTANT_NameAndType_info的索引项   |                          |        |
| CONSTANT_InterfaceMethodref_info | 接口中方法的符号引用     | tag                                                     | u1                       | 值为11 |
| index                            | u2                       | 指向声明方法的接口描述符CONSTANT_Class_info的索引项     |                          |        |
| index                            | u2                       | 指向名称及类型描述符CONSTANT_NameAndType_info的索引项   |                          |        |
| CONSTANT_NameAndType_info        | 字段或方法的部分符号引用 | tag                                                     | u1                       | 值为12 |
| index                            | u2                       | 指向该字段或方法名称常量项的索引                        |                          |        |
| index                            | u2                       | 指向该字段或方法描述符常量项的索引                      |                          |        |